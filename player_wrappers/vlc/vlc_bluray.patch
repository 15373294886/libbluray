diff --git a/configure.ac b/configure.ac
index 8556d25..948a56e 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1975,6 +1975,19 @@ fi
 
 
 dnl
+dnl  Blu-ray Disc Support with libbluray
+dnl
+AC_ARG_ENABLE(bluray,
+  AS_HELP_STRING([--enable-bluray],[use library libbluray for Blu-ray disc support]))
+if test "${enable_bluray}" != "no"
+then
+    AC_CHECK_HEADERS(libbluray/bluray.h,
+    [ VLC_ADD_PLUGIN([bluray])
+      VLC_ADD_CFLAGS([bluray],[])
+      VLC_ADD_LIBS([bluray],[-lbluray]) ])
+fi
+
+dnl
 dnl  OpenCV wrapper and example filters
 dnl
 PKG_ENABLE_MODULES_VLC([OPENCV], [opencv_example], [opencv], (OpenCV (computer vision) filter), [off])
@@ -4714,6 +4727,7 @@ AC_CONFIG_FILES([
   modules/access/Makefile
   modules/access/bd/Makefile
   modules/access/bda/Makefile
+  modules/access/bluray/Makefile
   modules/access/dshow/Makefile
   modules/access/dvb/Makefile
   modules/access/mms/Makefile
diff --git a/modules/access/Modules.am b/modules/access/Modules.am
index b7eefdf..0ae8b08 100644
--- a/modules/access/Modules.am
+++ b/modules/access/Modules.am
@@ -3,7 +3,7 @@
 # obviously does not. Here is a fix for that.
 LIBTOOL=@LIBTOOL@ --tag=CC
 
-BASE_SUBDIRS = dvb mms rtp rtsp vcd vcdx screen bd zip
+BASE_SUBDIRS = dvb mms rtp rtsp vcd vcdx screen bd zip bluray
 EXTRA_SUBDIRS = bda dshow
 SUBDIRS = $(BASE_SUBDIRS)
 DIST_SUBDIRS = $(BASE_SUBDIRS) $(EXTRA_SUBDIRS)
diff --git a/modules/access/bluray/Modules.am b/modules/access/bluray/Modules.am
new file mode 100644
index 0000000..d896056
--- /dev/null
+++ b/modules/access/bluray/Modules.am
@@ -0,0 +1,5 @@
+SOURCES_bluray = \
+    bluray.c \
+    $(NULL)
+
+libvlc_LTLIBRARIES += libbluray_plugin.la
diff --git a/modules/access/bluray/bluray.c b/modules/access/bluray/bluray.c
new file mode 100644
index 0000000..30ea17c
--- /dev/null
+++ b/modules/access/bluray/bluray.c
@@ -0,0 +1,282 @@
+/*****************************************************************************
+ * bluray.c: Blu-ray disc support plugin
+ *****************************************************************************
+ * Copyright (C) 2010 the VideoLAN team
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#ifdef HAVE_SYS_STAT_H
+#   include <sys/stat.h>
+#endif
+#include <limits.h>
+#include <vlc_common.h>
+#include <vlc_plugin.h>
+#include <vlc_access.h>
+#include <vlc_messages.h>
+#include <assert.h>
+#include <libbluray/bluray.h>
+
+/*****************************************************************************
+ * Module descriptor
+ *****************************************************************************/
+#define CACHING_TEXT N_("Caching value in ms")
+#define CACHING_LONGTEXT N_( \
+    "Caching value for BDs. This "\
+    "value should be set in milliseconds." )
+#define DEBUGMASK_TEXT N_("BD Debug mask")
+#define DEBUGMASK_LONGTEXT N_("Set up the debug mask value for libbluray")
+static int  blurayOpen ( vlc_object_t * );
+static void blurayClose( vlc_object_t * );
+
+vlc_module_begin ()
+    set_shortname( N_("BLURAY") )
+    set_description( N_("Blu-Ray Disc support (libbluray)") )
+    set_category( CAT_INPUT )
+    set_subcategory( SUBCAT_INPUT_ACCESS )
+    add_integer( "bluray-caching", 1000, NULL,
+        CACHING_TEXT, CACHING_LONGTEXT, true )
+    add_string("debug-mask", "0x0000", NULL,
+	       DEBUGMASK_TEXT, DEBUGMASK_LONGTEXT, false);
+    set_capability( "access", 60 )
+    add_shortcut( "bluray" )
+    add_shortcut( "file" )
+    set_callbacks( blurayOpen, blurayClose )
+vlc_module_end ()
+
+/*****************************************************************************
+ * Local prototypes
+ *****************************************************************************/
+
+struct access_sys_t
+{
+    void *dl_handle;
+    void *bluray;
+    int i_bd_delay;
+};
+
+static ssize_t blurayRead   (access_t *, uint8_t *, size_t);
+static block_t *blurayBlock (access_t *);
+static int     bluraySeek   (access_t *, uint64_t);
+static int     blurayControl(access_t *, int, va_list);
+static int     bluraySetTitle(access_t *p_access, int i_tile);
+
+/*****************************************************************************
+ * blurayOpen: module init function
+ *****************************************************************************/
+static int blurayOpen( vlc_object_t *object )
+{
+    char *debug_mask = NULL;
+    char *pos_title;
+    int i_title = 0;
+    access_t *p_access = (access_t*)object;
+    access_sys_t *p_sys;
+    char bd_path[512];
+
+    msg_Warn( p_access, "blurayOpen :)" );
+    if( !p_access->psz_location || !*p_access->psz_location ) {
+        msg_Warn( p_access, "blurayOpen - not selected" );
+        return VLC_EGENERIC;
+    }
+
+    var_Create( p_access, "bluray-caching", VLC_VAR_INTEGER|VLC_VAR_DOINHERIT );
+    var_Create( p_access, "debug-mask", VLC_VAR_STRING|VLC_VAR_DOINHERIT );
+    
+
+    debug_mask = var_GetString(p_access, "debug-mask");
+    if ( debug_mask ) {
+        setenv("BD_DEBUG_MASK", debug_mask, 1);
+    }
+
+    /* init access fields */
+    access_InitFields(p_access);
+
+    /* register callback function for communication */
+    ACCESS_SET_CALLBACKS(blurayRead, NULL, blurayControl, bluraySeek);
+
+    p_access->p_sys = p_sys = malloc(sizeof(access_sys_t));
+    if (!p_sys) {
+        msg_Warn( p_access, "cannot alloc access_sys memory");
+        return VLC_ENOMEM;
+    }
+
+    /* store current bd_path */
+    strncpy(bd_path, p_access->psz_location, sizeof bd_path);
+    if ( (pos_title = strrchr(bd_path, ':')) ) {
+        /* found character ':' for title information */
+        pos_title[0] = '\0';
+        i_title = atoi(pos_title + 1);
+    }
+
+    p_sys->bluray = bd_open(bd_path, NULL);
+    if ( p_sys->bluray == NULL ) {
+        return VLC_EGENERIC;
+    }
+
+    /* set start title number */
+    if ( bluraySetTitle(p_access, i_title) != VLC_SUCCESS ) {
+        return VLC_EGENERIC;
+    }
+
+    p_sys->i_bd_delay = var_GetInteger(p_access, "bluray-caching");
+
+    return VLC_SUCCESS;
+}
+
+
+
+/*****************************************************************************
+ * blurayClose: module destroy function
+ *****************************************************************************/
+static void blurayClose( vlc_object_t *object )
+{
+    access_t *p_access = (access_t*)object;
+    access_sys_t *p_sys = p_access->p_sys;
+
+    msg_Warn( p_access, "close bluray");
+    if ( p_sys->bluray != NULL ) {
+        bd_close(p_sys->bluray);
+    }
+}
+
+
+/*****************************************************************************
+ * bluraySetTitle: select new BD title
+ *****************************************************************************/
+static int bluraySetTitle(access_t *p_access, int i_title)
+{
+    access_sys_t *p_sys = p_access->p_sys;
+ 
+    /* select blue ray title */
+    if ( bd_select_title(p_access->p_sys->bluray, i_title) == 0 ) {
+        msg_Err( p_access, "cannot select bd title '%d'", p_access->info.i_title);
+        return VLC_EGENERIC;
+    }
+ 
+    /* read title length and init some values */
+    p_access->info.i_title = i_title;
+    p_access->info.i_size = bd_get_title_size(p_sys->bluray);
+    p_access->info.i_pos = 0;
+    p_access->info.b_eof = false;
+    p_access->info.i_seekpoint = 0;
+
+    return VLC_SUCCESS;
+}
+
+
+/*****************************************************************************
+ * blurayControl: handle the controls
+ *****************************************************************************/
+static int blurayControl(access_t *p_access, int query, va_list args)
+{
+    access_sys_t *p_sys = p_access->p_sys;
+    bool     *pb_bool;
+    int64_t  *pi_64;
+    uint32_t pos;
+
+    switch (query) {
+        case ACCESS_CAN_SEEK:
+        case ACCESS_CAN_FASTSEEK: 
+        case ACCESS_CAN_PAUSE:
+             pb_bool = (bool*)va_arg( args, bool * );
+             *pb_bool = true;
+             break;
+
+        case ACCESS_CAN_CONTROL_PACE:
+            pb_bool = (bool*)va_arg( args, bool* );
+            *pb_bool = true;
+            break;
+
+        case ACCESS_GET_PTS_DELAY:
+            pi_64 = (int64_t*)va_arg( args, int64_t * );
+            *pi_64 = p_sys->i_bd_delay;
+            break;
+
+        case ACCESS_SET_PAUSE_STATE:
+            /* Nothing to do */
+            msg_Warn( p_access, "set pause state");
+            break;
+
+        case ACCESS_SET_TITLE:
+
+            break;
+
+        case ACCESS_SET_SEEKPOINT:
+            pos = va_arg( args, uint32_t );
+            msg_Warn( p_access, "set seek position '%d'", pos);
+            break;
+
+        case ACCESS_GET_META:
+            return VLC_EGENERIC;
+            break;
+
+        case ACCESS_GET_TITLE_INFO:
+        case ACCESS_SET_PRIVATE_ID_STATE:
+        case ACCESS_GET_CONTENT_TYPE:
+            return VLC_EGENERIC;
+
+        default:
+            msg_Warn( p_access, "unimplemented query (%d) in control", query );
+            return VLC_EGENERIC;
+    }
+
+    return VLC_SUCCESS;
+}
+
+
+/*****************************************************************************
+ * bluraySeek: seek to the given position
+ *****************************************************************************/
+static int bluraySeek(access_t *p_access, uint64_t position)
+{
+    access_sys_t *p_sys = p_access->p_sys;
+
+    p_access->info.i_pos = bd_seek(p_sys->bluray, position);
+    p_access->info.b_eof = false;
+
+    return VLC_SUCCESS;
+}
+
+
+/*****************************************************************************
+ * blurayRead: read BD data into buffer
+ *****************************************************************************/
+static ssize_t blurayRead(access_t *p_access, uint8_t *data, size_t size)
+{
+    access_sys_t *p_sys = p_access->p_sys;
+    int nread;
+
+    if (p_access->info.b_eof) {
+        return 0;
+    }
+
+    /* read data into buffer with given length */
+    nread = bd_read(p_sys->bluray, data, size);
+
+    if( nread == 0 ) {
+        p_access->info.b_eof = true;
+    }
+    else if( nread > 0 ) {
+        p_access->info.i_pos += nread;
+    }
+
+    return nread;
+}
+  
+
-- 
1.7.1

